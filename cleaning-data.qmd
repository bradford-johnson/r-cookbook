# Cleaning Data

Cleaning data is one of the most important steps to any data analytics project. Cleaning data can involve anything from changing the case of characters from uppercase to lowercase to removing outliers from a data set, or even figuring out what to do with missing values. Having clean data is essential for making recommendations to stakeholders as your analysis can only be as strong as your data is clean. So very clean and structured data may lead you to entirely different insights than if you where to not clean it at all.

There are countless ways to clean your data in R, and I will show you different ways I have cleaned up data sets.

## Column Names (Headers)

However, first I think it is important to have clean and concise but descriptive headers, when dealing with tabular data. There have been many times where I load some data into R, and the headers are all uppercase, contain spaces, or something else that makes them annoying to work with. The `janitor` package is great because it can help clean up the headers (or column names) so they are easier to work with. I will load in the `readr` package to import a hand crafted `.csv` that I made as an example. I will load in the `dplyr` package so I can pipe the data into functions.

```{r warning=FALSE,message=FALSE,error=FALSE}
# load packages
library(janitor)
library(readr)
library(dplyr)

# read in csv with no changes
dirty_df <- read_csv('janitor-example.csv')

# read in csv but with janitor and dplyr functions
clean_df <- read_csv('janitor-example.csv') %>%
  clean_names() %>%
  mutate(weather_condition = w_ea_th_er_conditions) %>%
  mutate(avg_temp_f = temp_f) %>%
  mutate(weekday = day_of_the_week) %>%
  select(weekday, avg_temp_f, weather_condition)
```

Here is how the original data frame and cleaned data frame look. The column names are now easier to work with, and better understood.

```{r}
# head()
dirty_df %>% 
  head()

clean_df %>%
  head()
```

## Filter and Mutate Data

Many times you may need to filter data, for example if you only want to see observations on a specific weekday, or with certain values. That is easy to do and with the `dplyr` package you will be able to really be creative with filtering, creating additional columns, and much more.

For some of these examples I will use some data sets that come with R, the first data set we will look at is `chickwts` which looks at baby chick weights and feed types. I am going to summarize the counts for the feeds to quickly see all the options. Then I will filter some of the feeds as they are no longer available for my stakeholder in this scenario.

```{r}
# load packages and data 
library(dplyr)

chick_df <- chickwts

# counts for each feed type
chick_df %>%
  group_by(feed) %>%
  summarise(n = n())
```

```{r}
# keep feeds: sunflower, soybean, linseed
chick_feeds <- chick_df %>%
  filter(feed == 'sunflower' | feed == 'soybean' | feed == 'linseed')

# counts for each type of feed
chick_feeds %>%
  group_by(feed) %>%
  summarise(n = n())
```

How about a different filter that returns all rows that have weights below 200 units, and are linseed or horsebean feeds.

```{r}
chick_df %>%
  filter(weight < 200 & feed == 'linseed' | weight < 200 & feed == 'horsebean')
```

Now I am going to use the `mutate()` function to create a new column, and this column will be used to classify a chicks weight category based on some predetermined values.

> For this example lets say these are the weight classes:
>
> > weight \< 200 - **underweight**
> >
> > weight \>= 200 & weight \<= 300 - **normal**
> >
> > weight \> 300 - **overweight**

```{r}
# mutate() and casewhen()
chick_classes <- chick_df %>%
  mutate(weight_class = case_when(
    weight < 200 ~ 'underweight',
    weight >= 200 & weight <= 300 ~ 'normal',
    weight > 300 ~ 'overweight'
    ))

# view results
chick_classes

chick_classes %>% 
  group_by(weight_class) %>%
  summarise(n = n())
```
